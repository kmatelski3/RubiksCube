/* autogenerated by Processing revision 1293 on 2024-01-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Random;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class RubiksCube extends PApplet {

int size = 3;
PMatrix3D baseMat;
int[] colors = {0xFFFFFFFF, 0xFFFE8D01, 0xFF009B48, 0xFFB90000, 0xFF0046AD, 0xFFFFD500};
public final int white = colors[0];
public final int orange = colors[1];
public final int green  = colors[2];
public final int red = colors[3];
public final int blue = colors[4];
public final int yellow = colors[5];

//Defining directions
public static final int up = 0;
public static final int left = 1;
public static final int front = 2;
public static final int right = 3;
public static final int back = 4;
public static final int down = 5;
public static final int eslice = 6;
public static final int sslice = 7;
public static final int mslice = 8;

Piece[] cube = new Piece[size*size*size];
Piece[] solvedState = new Piece[size*size*size];
public static final int mult = 14;


long currTime = 0;
long startTime = 0;
float displayTime = 0;

boolean solveStarted = true;
boolean currentOngoingSolve = false;




String scramble = new String();

public void setup() {
 /* size commented out by preprocessor */;
 baseMat = getMatrix(baseMat);
  int index = 0;
  for (int i = -1; i <= 1; i++) {
     for (int j = -1; j <=1; j++) {
       for (int k = -1; k <= 1; k++) {
         PMatrix3D matrix = new PMatrix3D();
         matrix.translate(mult*i,mult*j,mult*k);
         solvedState[index] = new Piece(matrix, mult*i, mult*j, mult*k);
         cube[index++] =  new Piece(matrix, mult*i, mult*j, mult*k);
       }
     }
   }
}

public void front(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].z == mult) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(cube[i].x, cube[i].y);
      cube[i].turnFace(front, prime);
      cube[i].updatePos(round(matrix.m02), round(matrix.m12), cube[i].z);
    }
  }
}

public void back(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].z == -mult) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*-HALF_PI);
      matrix.translate(cube[i].x, cube[i].y);
      cube[i].turnFace(back, prime);
      cube[i].updatePos(round(matrix.m02), round(matrix.m12), cube[i].z);
    }
  }
}

public void right(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].x == mult) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(cube[i].y, cube[i].z);
      cube[i].turnFace(right, prime);
      cube[i].updatePos(cube[i].x, round(matrix.m02), round(matrix.m12));
    }
  }
}

public void left(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].x == -mult) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*-HALF_PI);
      matrix.translate(cube[i].y, cube[i].z);
      cube[i].turnFace(left, prime);
      cube[i].updatePos(cube[i].x, round(matrix.m02), round(matrix.m12));
    }
  }
}

public void up(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].y == -mult) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(cube[i].x, cube[i].z);
      cube[i].turnFace(up, prime);
      cube[i].updatePos(round(matrix.m02), cube[i].y, round(matrix.m12));
    }
  }
}

public void down(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].y == mult) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*-HALF_PI);
      matrix.translate(cube[i].x, cube[i].z);
      cube[i].turnFace(down, prime);
      cube[i].updatePos(round(matrix.m02), cube[i].y, round(matrix.m12));
    }
  }
}

public void eslice(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].y == 0) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*-HALF_PI);
      matrix.translate(cube[i].x, cube[i].z);
      cube[i].turnFace(eslice, prime);
      cube[i].updatePos(round(matrix.m02), cube[i].y, round(matrix.m12));
    }
  }
}

public void sslice(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].z == 0) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(cube[i].x, cube[i].y);
      cube[i].turnFace(sslice, prime);
      cube[i].updatePos(round(matrix.m02), round(matrix.m12), cube[i].z);
    }
  }
}

public void mslice(int prime){
  for (int i = 0; i < cube.length; i++) {
    if(cube[i].x == 0) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*-HALF_PI);
      matrix.translate(cube[i].y, cube[i].z);
      cube[i].turnFace(mslice, prime);
      cube[i].updatePos(cube[i].x, round(matrix.m02), round(matrix.m12));
    }
  }
}

public void zRotate(int prime) {
  for (int i = 0; i < cube.length; i++) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(cube[i].x, cube[i].y);
      cube[i].turnFace(front, prime); //front = same dir as a z rotation
      cube[i].updatePos(round(matrix.m02), round(matrix.m12), cube[i].z);
  }
}

public void yRotate(int prime){
  for (int i = 0; i < cube.length; i++) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(cube[i].x, cube[i].z);
      cube[i].turnFace(up, prime);//up = same dir as y rotation
      cube[i].updatePos(round(matrix.m02), cube[i].y, round(matrix.m12));
  }
}

public void xRotate(int prime){
  for (int i = 0; i < cube.length; i++) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(cube[i].y, cube[i].z);
      cube[i].turnFace(right, prime);//right = same dir as x rotation
      cube[i].updatePos(cube[i].x, round(matrix.m02), round(matrix.m12));
  }
}

public void zRotateSS(int prime) {
  for (int i = 0; i < cube.length; i++) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(solvedState[i].x, solvedState[i].y);
      solvedState[i].turnFace(front, prime); //front = same dir as a z rotation
      solvedState[i].updatePos(round(matrix.m02), round(matrix.m12), solvedState[i].z);
  }
}

public void yRotateSS(int prime){
  for (int i = 0; i < cube.length; i++) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(solvedState[i].x, solvedState[i].z);
      solvedState[i].turnFace(up, prime);//up = same dir as y rotation
      solvedState[i].updatePos(round(matrix.m02), solvedState[i].y, round(matrix.m12));
  }
}

public void xRotateSS(int prime){
  for (int i = 0; i < cube.length; i++) {
      PMatrix2D matrix = new PMatrix2D();
      matrix.rotate(prime*HALF_PI);
      matrix.translate(solvedState[i].y, solvedState[i].z);
      solvedState[i].turnFace(right, prime);//right = same dir as x rotation
      solvedState[i].updatePos(solvedState[i].x, round(matrix.m02), round(matrix.m12));
  }
}

public void draw() {
  background(0);
  
  pushMatrix();
  camera(0,-200*mult,250*mult,   0,0,0,   0,1,0);
  scale(50);
  for (int i = 0; i < cube.length; i++) {
    cube[i].show();
  }
  popMatrix();
  
  this.setMatrix(baseMat);
  fill(255);
  textSize(30);
  text(scramble, 170, 50);
  currTime = System.nanoTime();
  if (!isSolved() && currentOngoingSolve && solveStarted) { //if there is a solve ongoing and also the solve has been started
    displayTime = (currTime - startTime)/1000000000.0f;
  } else if (isSolved()){
    currentOngoingSolve = false;
  }
  //print(displayTime);
  text(displayTime, 900, 250);
}

public boolean isSolved() {
  int count = 0;
  // LINES UP RED CENTER
  if (solvedState[4].y!=cube[4].y)  {
    count = 0;
    while (!solvedState[4].isEqual(cube[4]) && count < 4) {
      zRotateSS(1);
      count++;
    }
    count = 0;
    while (!solvedState[4].isEqual(cube[4]) && count < 4) {
      xRotateSS(1);
      count++;
    }
  } else {
    count = 0;
    while (!solvedState[4].isEqual(cube[4]) && count < 4) {
      yRotateSS(1);
      count++;
    }
  }
  //LINES UP WHITE CENTER
  count = 0;
  if (solvedState[4].y !=0) {
    while (!solvedState[16].isEqual(cube[16]) && count < 4) {
      yRotateSS(1);
      count++;
    }
  } 
  else if (solvedState[4].x !=0){
    while (!solvedState[16].isEqual(cube[16]) && count < 4) {
      xRotateSS(1);
      count++;
    }
  }
  else if (solvedState[4].z !=0)  {
    while (!solvedState[16].isEqual(cube[16]) && count < 4) {
      zRotateSS(1);
      count++;
    }
  }
  
    
  zRotate(1);
  zRotate(-1);
  
  for (int i = 0; i < cube.length; i++) {
    if (!cube[i].isEqual(solvedState[i])){
      return false;
    }
  }
  return true;
}

public void startSolve() {
  setup();
  zRotate(1);
  zRotate(1);
  ScrambleGenerator scrambleGen = new ScrambleGenerator(20);
  scramble = scrambleGen.getScramble();   
  solveStarted = false;
  currentOngoingSolve = true;
}
class Piece {
  PMatrix3D m;
  int x;
  int y;
  int z;
  Sticker[] stickers = new Sticker[6];
  
  public Piece(PMatrix3D m, int x, int y, int z) {
    this.m = m;
    this.x = x;
    this.y = y;
    this.z = z;
    
    if (x == mult) {
      stickers[1] = new Sticker(new PVector(mult,0,0), orange);
    } else if (x == -mult) {
      stickers[3] = new Sticker(new PVector(-mult,0,0), red);
    }
    if (y == mult) {
      stickers[0] = new Sticker(new PVector(0,mult,0), white);
    } else if (y == -mult) {
      stickers[5] = new Sticker(new PVector(0,-mult,0), yellow);
    }
    if (z == mult) {
      stickers[4] = new Sticker(new PVector(0,0,mult), green);
    } else if (z == -mult) {
      stickers[2] = new Sticker(new PVector(0,0,-mult), blue);
    }
  }
  
  
  public void show() {
    noFill();
    stroke(0);
    strokeWeight(.1f);
    pushMatrix();
    applyMatrix(m);
    for(Sticker s: stickers) {
      if(s == null) {continue;}
      s.show();
    }
    popMatrix();
  }
  
  public void updatePos(int x, int y, int z) {
    m.reset();
    m.translate(x, y, z);
    this.x = x;
    this.y = y;
    this.z = z;
  }
  
  public void turnFace(int dir, int prime) {
    switch(dir) {
      
      case back: 
        for (Sticker s : stickers) {
          if(s == null) {continue;}
          s.turnZ(prime * -HALF_PI);
        }
        break;
        
      case front: 
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnZ(prime * HALF_PI);
        }
        break;
        
      case right:
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnX(prime * HALF_PI);
        }
        break;
      case left: 
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnX(prime * -HALF_PI);
        }
        break;
      case up: 
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnY(prime * HALF_PI);
        }
        break;
      case down:
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnY(prime * -HALF_PI);
        }
        break;
      case eslice:
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnY(prime * -HALF_PI);
        }
        break;
      case sslice:
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnZ(prime * HALF_PI);
        }
        break;
      case mslice:
        for (Sticker s: stickers) {
          if(s == null) {continue;}
          s.turnX(prime * -HALF_PI);
        }
        break;
      
    }
  }
  public boolean isEqual(Piece p) {
    for (int i = 0; i < stickers.length; i++) {
      if (stickers[i] == null && p.stickers[i] == null) {continue;}
      if (stickers[i] ==null || p.stickers[i] == null || !stickers[i].isEqual(p.stickers[i])) {
        return false;
      }
    }
    return true;
  }
}


/**
 * Creates a random algorithm to scramble the Rubik's Cube (3x3) with a number of moves
 * (25 recommended for a good scramble) defined by the user.
 *
 * Created by mrxuso on 13/07/16.
 */

public class ScrambleGenerator {

    /**
    * MOVE -> 1 - U, 2 - L, 3 - F, 4 - D, 5 - R, 6 - B
    * ROTATION -> 1 - X, 2 - 2X, 3 - X', 4 - 2X
    */
    int mLastFace = 0, mTwoFacesAgo = 0;
    private String mScramble = "";

    /**
    * Constructor: create a scramble algorithm with "algorithmLength" number of moves
    * @param algorithmLength Define the length of the algorithm
    */
    public ScrambleGenerator(int algorithmLength) {
        for (int i = 1; i <= algorithmLength; i++) {
            mScramble += getNextMove();
        }
    }
    

    /**
    * Next face we move in the algorithm, it is different from the last move and from the face moved
    * two times ago if the opposite face was moved in the last move (i.e. R L 2R is incorrect, it should be R' L instead).
    * @return random A number between 1 and 6 (both included) --> 1 - U, 2 - L, 3 - F, 4 - D, 5 - R, 6 - B <--
    */
    private int getNextFace(){
        int random = (new Random().nextInt(6) + 1);
        
        /*We generate a face different from the one two moves ago if we moved
        * the opposite face in the previous move and different from the last face we moved
        */
        while (random == mTwoFacesAgo && random%3 == mLastFace%3 || random == mLastFace) {
            random = (new Random().nextInt(6) + 1);
        }

        //We save the last face moved and the one moved two times ago
        mTwoFacesAgo = mLastFace;
        mLastFace = random;

        //We return the random number of the face
        return random;
    }
    /**
    * Next rotation of the face (there are no constraints) --> 1 - X, 2 - 2X, 3 - X', 4 - 2X <--
    */
    private int getNextRotation(){

        //We return a random number between 1 and 4 indicating the rotation of the face
        return (new Random().nextInt(4) + 1);
    }

    /**
    * Concatenates the rotation and the movement (X, X', 2X)
    */
    private String getNextMove(){
        String nextMove = "";

        // --> 1 - U, 2 - L, 3 - F, 4 - D, 5 - R, 6 - B <--
        switch (getNextFace()){
            case 1:
                nextMove = "U";
                break;
            case 2:
                nextMove = "L";
                break;
            case 3:
                nextMove = "F";
                break;
            case 4:
                nextMove = "D";
                break;
            case 5:
                nextMove = "R";
                break;
            case 6:
                nextMove = "B";
                break;
        }

        // --> 1 - X, 2 - X', 3&4 - 2X <--
        switch (getNextRotation()){
case 1:
                switch (nextMove) {
                  case "U":
                    up(1);
                    break;
                  case "L":
                    left(1);
                    break;
                  case "F":
                    front(1);
                    break;
                  case "D":
                    down(1);
                    break;
                  case "R":
                    right(1);
                    break;
                  case "B":
                    back(1);
                    break;
                }
                break;
            case 2:
                switch (nextMove) {
                  case "U":
                    up(-1);
                    break;
                  case "L":
                    left(-1);
                    break;
                  case "F":
                    front(-1);
                    break;
                  case "D":
                    down(-1);
                    break;
                  case "R":
                    right(-1);
                    break;
                  case "B":
                    back(-1);
                    break;
                }
                nextMove = nextMove + "'";
                break;
            case 3:
            case 4:
                switch (nextMove) {
                  case "U":
                    up(1);
                    up(1);
                    break;
                  case "L":
                    left(1);
                    left(1);
                    break;
                  case "F":
                    front(1);
                    front(1);
                    break;
                  case "D":
                    down(1);
                    down(1);
                    break;
                  case "R":
                    right(1);
                    right(1);
                    break;
                  case "B":
                    back(1);
                    back(1);
                    break;
                }
                nextMove = nextMove + "2";
                break;
        }

        //We add a space between the moves
        return nextMove + " ";
    }

    /**
    * @return mScramble The full algorithm for scrambling the cube
    */
    public String getScramble(){
        return mScramble;
    }
}
class Sticker {
  PVector normal;
  int c;
  
  public Sticker(PVector normal, int c) {
    this.normal = normal;
    this.c = c;
  }
  
  public void turnX(float angle) {
    PVector v = new PVector();
    v.y = round(normal.y * cos(angle) - normal.z * sin(angle));
    v.z = round(normal.y * sin(angle) + normal.z * cos(angle));
    v.x = normal.x;
    normal = v;
  }
  
  
  public void turnY(float angle) {
    PVector v = new PVector();
    v.x = round(normal.x * cos(angle) - normal.z * sin(angle));
    v.z = round(normal.x * sin(angle) + normal.z * cos(angle));
    v.y = normal.y;
    normal = v;
  }
  
  
  public void turnZ(float angle) {
    PVector v = new PVector();
    v.x = round(normal.x * cos(angle) - normal.y * sin(angle));
    v.y = round(normal.x * sin(angle) + normal.y * cos(angle));
    v.z = normal.z;
    normal = v;
  }
  
  public void show() {
    pushMatrix();
    fill(c);
    noStroke();
    rectMode(CENTER);
    translate(normal.x/2, normal.y/2, normal.z/2);
    if (abs(normal.x) > 0) {
      rotateY(HALF_PI);
    } else if (abs(normal.y) > 0){
      rotateX(HALF_PI);
    }
    square(0,0,0.8f*mult);
    popMatrix();
  }
  
  public boolean isEqual(Sticker s) {
    return (normal.equals(s.normal) && c == s.c);
  }
  
}
public void keyPressed() {
  if (!solveStarted && (key == 'e' || key == 'd' || key == 'i' || key == 'k' || key == 'j' || key == 'f' || key == 's' || key == 'l' || key == 'h' || key == 'g' || key == 'w' ||
                                                   key == 'o' || key == '2' || key == '9' || key == '1' || key == '0' || key == '.' || key == 'x' || key == '5' || key == '6' ||
                                                   key == 'u' || key == 'm' || key == 'v' || key == ',' || key == 'c' || key == 'z' || key == '/')) {
        startTime = System.nanoTime();
        solveStarted = true;
      }
  switch (key) {
    //NORMAL MOVES
    case 'e':
      left(-1);
      break;
    case 'd':
      left(1);
      break;
    case 'i':
      right(1);
      break;
    case 'k':
      right(-1);
      break;
    case 'j':
      up(1);
      break;
    case 'f':
      up(-1);
      break;
    case 's':
      down(1);
      break;
    case 'l':
      down(-1);
      break;
    case 'h':
      front(1);
      break;
    case 'g':
      front(-1);
      break;
    case 'w':
      back(1);
      break;
    case 'o':
      back(-1);
      break;
    
    //SLICES
    //E SLICE
    case '2':
      eslice(1);
      break;
    case '9':
      eslice(-1);
      break;
    //S SLICE
    case '1':
      sslice(-1);
      break;
    case '0':
      sslice(1);
      break;
    //M SLICE
    case '.':
    case 'x':
      mslice(-1);
      break;
    case '5':
    case '6':
      mslice(1);
      break;
      
    
    //ROTATIONS
    // z rotations
    case 'p':
      zRotate(1);
      break;
    case 'q':
      zRotate(-1);
      break;
    // y rotations
    case ';':
      yRotate(1);
      break;
    case 'a':
      yRotate(-1);
      break;
    //x rotations
    case 'b':
    case 'n':
      xRotate(-1);
      break;
    case 't':
    case 'y':
      xRotate(1);
      break;
      
      
   //WIDE MOVES
   //Rw
   case 'u':
     right(1);
     mslice(-1);
     break;
   case 'm':
     right(-1);
     mslice(1);
     break;
   //Lw
   case 'v':
     left(1);
     mslice(1);
     break;
   case 'r':
     left(-1);
     mslice(-1);
     break;
   //Uw
   case ',':
     up(1);
     eslice(-1);
     break;
   case 'c':
     up(-1);
     eslice(1);
     break;
   //Dw
   case 'z':
     down(1);
     eslice(1);
     break;
   case '/':
     down(-1);
     eslice(-1);
     break;
     
   //SCRAMBLE
   case ' ':
     if (isSolved()){
     startSolve();
     }
     break;
   //BUG TESTING
   case '=':
     setup();
     break;
  }
  
}


  public void settings() { size(1000, 700, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "RubiksCube" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
